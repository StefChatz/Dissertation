% $Id: chapter1.tex 1790 2010-09-28 16:46:40Z jabriffa $

\chapter{Introduction}

\section{Background}
Current social news sites try to produce a list of current important news items by applying algorithms
and voting by the community. While more decentralized than a traditional publication, the system still
relies on a select few(moderators, administrators) to safeguard it from manipulation (spam, vote-rigging)
while maintaining the culture of the website. Further, by providing a centralized view of the current news,
they necessarily average the preferences of their members instead of addressing the needs of each one based on their voting patterns. This project aims to develop a new type of social news aggregator that allows each user to see a personalized view of current events while allowing them to customize the algorithm by which the items get selected.

\section {Aims \& Objectives}
The solution, which will first be theorized and made into an algorithm, will first be comprised of the combination of the most critical aspects of the most popular sorting and ranking solutions out there while tailoring the final solution to one that fits a social news aggregator.
\begin{enumerate}
 \item Develop a Functioning website with users that can create, edit their posts and view all of the users post ranked by timestamp.
 \item Compare the most commonly used algorithms, critique the positive and negative attributes and theorize, which parts of each algorithm should be implemented in the final implementation.
 \item Compare the relevancy of the results after the final version of the algorithm has been implemented.
\end{enumerate}

\subsection {Project Limitations}
Since the development of this project was initiated the goal was to create a testing platform
on which to compare the results of the implementation of the final algorithm in a real-world
environment. Thus, the scalability of the project as a whole was not taken into consideration. Having that said, the issue of scalability would occur not because of the algorithm itself, but
due to the reason that the software developed does not address many security issues as well as
correct optimization so that the system would be able to hold on with more users.

\section{Design Process and Technologies used}
During the entire design and implementation process, I decided to use python. This choice was made originally for the ease of implementing algorithms in a scripting language like python. However, as I progressed from the testing phase to the development phase, I was faced with a dilemma. Either to re-implement most of the progress I had made to a language that was more web and browser-based like JavaScript, or creates a hybrid of both front-end and back-end schemes. Having that said, after some research online, I decided to use Django, which is a high-level Python Web framework that encourages rapid development and clean, pragmatic design.

\subsection{Django Framework}
Django is a framework that was built as a tool for front-end developers that needed a simple way to bring their ideas to life without the need of a back-end developer that handles processes such as creating and connecting the server-side with the client-side as well as the creation and handling of the system's database. Furthermore, Django is based on the python programming as the main language and HTML for the front-end and SQLite as a relational database. Moreover, Django uses an MVC pattern similar to the more widely used MVC that frameworks like Ruby and Ruby on Rails use.

\subsection{Software Development Lifecycle}

\subsection{Chosen Methodology}

\subsection{Report Structure}
