% $Id: chapter1.tex 1790 2010-09-28 16:46:40Z jabriffa $

\chapter{Introduction}

\section{Background}
Current social news sites try to produce a list of current important news items by applying algorithms
and voting by the community. While more decentralized than a traditional publication, the system still
relies on a select few(moderators, administrators) to safeguard it from manipulation (spam, vote-rigging)
while maintaining the culture of the website. Further, by providing a centralized view of the current news,
they necessarily average the preferences of their members instead of addressing the needs of each one based on their voting patterns. This project aims to develop a new type of social news aggregator that allows each user to see a personalized view of current events while allowing them to customize the algorithm by which the items get sorted.

\section {Aims \& Objectives}
The solution, which will first be theorized and made into an algorithm, will first be comprised of the combination of the most critical aspects of the most popular sorting and ranking solutions out there while tailoring the final solution to one that fits a social news aggregator.

\begin{enumerate}
\item Develop a Functioning website with users that can create, edit their posts and view all of the users post ranked by timestamp.
\item Compare the most commonly used algorithms, critique the positive and negative attributes and theorize, which parts of each algorithm should be implemented in the final implementation.
\item Compare the relevancy of the results after the final version of the algorithm has been implemented.
\item Create a modern and responsive website that is easy to use and compatible with a variety of screen resolutions. In order for the functionality of the program to be more clear.
\end{enumerate}

\subsection {Project Limitations}
Since the development of this project was initiated the goal was to create a testing platform
on which to compare the results of the implementation of the final algorithm in a real-world
environment. Thus, the scalability of the project as a whole was not taken into consideration. Having that said, the issue of scalability would occur not because of the algorithm itself, but
due to the reason that the software developed does not address many security issues as well as
correct optimization so that the system would be able to hold on with more users.


\section{Software Development Life Cycle}
Software Development Life Cycle (SDLC) is the process that a software project follows to develop and test the system. A Software Development Life Cycle can be thought of as a master plan that describes how the the development, testing, enhancement and maintaining processes should occur during the implementation of the software \cite{stackify_2017_what}.

The goal of the SDLC is to produce a software with the highest quality at the lowest possible cost. In order to achieve this, SDLC provides six phases that are consistent with the most popular methodologys such as waterfall, spiral and Agile \cite{stackify_2017_what}.

The SDLC phases include:
\begin{itemize}
  \item Requirement analysis
  \item Planning
  \item Software design such as architectural design
  \item Software development
  \item Testing
  \item Deployment
\end{itemize}

The most traditional method for software development is the Waterfall methodology. Waterfall, delivers the above phases in a linear fashion, meaning that each phase can begin only after the previous has been completed. Moreover, thanks to the implementation of the phases, the waterfall methodology becomes a fairly straightforward process. However, a process can never be repeated unless a critical error occurs that requires the revision of a previous phase. This makes it incredibly risky to use in a final year project development environment since fully following the methodology, could prove difficult to address the arising errors that are bound to occur.

A more common methodology in the recent years is the Agile development approach. This approach takes the phases previously mentioned and creates the so called sprints. The sprint's duration usually is a couple of weeks long with pre-specified goals set at the beginning of each sprint. Each sprint can be thought of as a many smaller implementation of the waterfall approach, since the phases are consistent with both methodologies but since agile is comprised of sprints, during each sprint each phase will re-occur.

\section{Chosen Methodology}
After considering most of the commonly used methodologies, and due to time limitations, I decided that I was not going to use a methodology that was too complicated or had too many restrictions. Having that said, I chose the Agile development methodology using the Kanban framework. The goal of using this framework is to aid the developer in the categorisation and prioritisation of the work and tasks. Furthermore, the agile methodology was chosen since before the development; the technologies used were previously known. Having that said, the development will be broken down into small increments which will encourage the mastery of the technologies used after each sprint. Lastly, the sprints will allow for overall better testing and feedback since they will be received after each sprint.

\section{Report Structure}
The report structure will mirror the planning and development process as it occurred. First, by reviewing and constructing the ideal ranking algorithm for a social news aggregator following the development of the web application which will implement the constructed algorithm.

\section{Summary}
Overall the introduction chapter has portrayed an overview of the project's definition, flow and goals as well as addressing how the project will deal with the different phases of development through defining the methodology.
